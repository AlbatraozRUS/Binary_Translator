# Компилятор для "Тюремного языка"
## Преамбула
Данный проект является логическим завершением курса Дединского И.Р. по `ASM x86-64`, продолжая идею собственного языка. В рамках финального проекта прошлого семестра был создан проект [Language](https://github.com/AlbatraozRUS/Language), в котором в качестве базы был создан `Тюремный язык` с синтаксисом похожим на C.
### Пример квадратного уравнения
```
Залететь на зону главный ()
{
Бесконечно = 3

Никто      = 0

По какой статье ( Авторитет )

По какой статье ( Бродяга )

По какой статье ( Сосунок )

На какой стул сядешь ( Авторитет = 0 )
    стул 1:

    На какой стул сядешь ( Бродяга = 0 )
        стул 1:

        На какой стул сядешь ( Сосунок = 0 )
            стул 1:

            Кто по жизни ( Бесконечно )
            }

            стул 2:

            Кто по жизни ( Никто )
            }
        }

        стул 2:

        Лох = (0 - 1) * Сосунок / Бродяга
        Кто по жизни ( Лох )
        }
    }

    стул 2:
        Дебил = Бродяга * Бродяга - 4 * Авторитет * Сосунок

        На какой стул сядешь ( Дебил = 0 )
        Стул 1:
            Первый = ((0 - 1) * Бродяга ) / ( Авторитет * 2 )
            Кто по жизни ( Первый )
            }
        Cтул 2:
            На какой стул сядешь ( Дебил > 1 )
            Стул 1:
                Дебил = корешок ( Дебил )
                Первый = ((0 - 1) * Бродяга + Дебил ) / ( Авторитет * 2 )
                Второй = ((0 - 1) * Бродяга - Дебил ) / ( Авторитет * 2 )
                Кто по жизни ( Первый )
                Кто по жизни ( Второй )
            }

            Стул 2:
                Кто по жизни ( Лох )
                }
            }
    }
}
Базар окончен!
```
### Краткий обзор языка
- `Залететь на зону <func_name>()` - объявление входа в функцию
- `Кто по жизни (<var_name>)` - распечатать переменную <var_name>
- `По какой статье (<var_name>)` - считать переменную <var_name>
- `На какой стул сядешь (<condition>) стул 1: <code>} стул 2: <code>}` - аналог конструкции `if`
- `Погонять (<condition>) <code>}` - аналог конструкции `while`
- Присутствуют стандартные арифметические операции (+, -, *, /), а также вычисление квадратного корня.
- Возможен рекурсивный вызов функций
- Присутствует работа с отрицательными числами с фиксированной точностью

Выходными данными этой программы был файл в формате .txt в формате моего варианта ассемблера из проекта 
[Процессор](https://github.com/AlbatraozRUS/Soft_Processor), который в дальнейшем на нем же можно было и выполнить.
## Цель
Написать проект, который бы принимал текстовый файл, в котором бы была написана какая-то программа на `Тюремном языке`, а на выходе мы бы получали исполняемый файл в формате **ELF**. 
## Ход работы
В ходе написания проекта было решено в качестве основы взять стандарт дерева и "FrontEnd" от проекта [Language](https://github.com/AlbatraozRUS/Language), тогда необходимо было реализовать 2 части:
-  Создание `ELF` файла
-  Переписать BackEnd для работы с `ASM x86-64`

В изучении формата ELF файла помогла работа моего коллеги, [alpocnito](https://github.com/alpocnito), ["ссылка на его туториал"](https://github.com/alpocnito/Create-elf-in-10-minuts).
Касательно нового BackEnd, то необходимо было полностью изменить процесс обработки элементов дерева, сделать запись в формате `ASM x86-64`, а также написать собственные версии `printf()` и `scanf()` с упрощенным функционалом (работа с числами с фиксированной точностью, в том числе с отрицательными). 


## Итоги 
Помимо того, что удалось успешно создать некоторую упрощенную версию компилятора `Тюремного языка`, я также  замерил скорость выполнения работы (для профиллирования использовалась стандартная утилита `time`). Для этого мною был запущен подсчет [факториала 10](https://github.com/AlbatraozRUS/Language/blob/master/Factorial.txt) в цикле, и на основании полученных результатов я сравнил время с выполнением в результате работы проекта `Language`, а также после изучения генерируемого кода написал небольшую оптимизацию при работе с переменными, которая дала прирост приблизительно на 9 процентов.
| **Проект**  | **Количество иттераций цикла** | **Время выполнения в секундах** | 
|:----------:|-------------:|:----------:|
| `Language` | 1 000 000 | 66,42 |
| `Compiler_x86-64` | 100 000 000 | 6,97 |
| `Compiler_x86-64` с оптимизацией | 100 000 000 | 6,35 |

Как можно заметить мы получили колоссальное ускорение в **1046(!) раз**. Подобный результат оправдал потрачнные усилия. 
